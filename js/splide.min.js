function _defineProperties(n, t) {
	for (let e = 0; e < t.length; e++) {
		let i = t[e]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(n, i.key, i)
	}
} function _createClass(n, t, e) {
	return t && _defineProperties(n.prototype, t), e && _defineProperties(n, e), Object.defineProperty(n, 'prototype', { writable: !1 }), n
}!(function (n, t) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : (n = typeof globalThis !== 'undefined' ? globalThis : n || self).Splide = t()
})(this, () => {
	let d = '(prefers-reduced-motion: reduce)'; let R = 4; let W = 5; let n = { CREATED: 1,
		MOUNTED: 2,
		IDLE: 3,
		MOVING: R,
		SCROLLING: W,
		DRAGGING: 6,
		DESTROYED: 7 }; function x(n) {
		n.length = 0
	} function _(n, t, e) {
		return Array.prototype.slice.call(n, t, e)
	} function D(n) {
		return n.bind.apply(n, [null].concat(_(arguments, 1)))
	} function G() {} let v = setTimeout; function p(n) {
		return requestAnimationFrame(n)
	} function t(n, t) {
		return typeof t === n
	} function X(n) {
		return !r(n) && t('object', n)
	} let o = Array.isArray; let w = D(t, 'function'); let M = D(t, 'string'); let z = D(t, 'undefined'); function r(n) {
		return n === null
	} function g(n) {
		return n instanceof HTMLElement
	} function m(n) {
		return o(n) ? n : [n]
	} function y(n, t) {
		m(n).forEach(t)
	} function b(n, t) {
		return n.indexOf(t) > -1
	} function E(n, t) {
		return n.push.apply(n, m(t)), n
	} function L(t, n, e) {
		t && y(n, (n) => {
			n && t.classList[e ? 'add' : 'remove'](n)
		})
	} function C(n, t) {
		L(n, M(t) ? t.split(' ') : t, !0)
	} function P(n, t) {
		y(t, n.appendChild.bind(n))
	} function k(n, e) {
		y(n, (n) => {
			let t = (e || n).parentNode; t && t.insertBefore(n, e)
		})
	} function B(n, t) {
		return g(n) && (n.msMatchesSelector || n.matches).call(n, t)
	} function S(n, t) {
		n = n ? _(n.children) : []

		return t ? n.filter((n) => {
			return B(n, t)
		}) : n
	} function A(n, t) {
		return t ? S(n, t)[0] : n.firstElementChild
	} let h = Object.keys; function N(n, t, e) {
		if (n) {
			for (var i = h(n), i = e ? i.reverse() : i, o = 0; o < i.length; o++) {
				let r = i[o]; if (r !== '__proto__' && !1 === t(n[r], r)) {
					break
				}
			}
		}

		return n
	} function T(i) {
		return _(arguments, 1).forEach((e) => {
			N(e, (n, t) => {
				i[t] = e[t]
			})
		}), i
	} function O(e) {
		return _(arguments, 1).forEach((n) => {
			N(n, (n, t) => {
				o(n) ? e[t] = n.slice() : X(n) ? e[t] = O({}, X(e[t]) ? e[t] : {}, n) : e[t] = n
			})
		}), e
	} function I(t, n) {
		m(n || h(t)).forEach((n) => {
			delete t[n]
		})
	} function F(n, e) {
		y(n, (t) => {
			y(e, (n) => {
				t && t.removeAttribute(n)
			})
		})
	} function j(e, t, i) {
		X(t) ? N(t, (n, t) => {
			j(e, t, n)
		}) : y(e, (n) => {
			r(i) || i === '' ? F(n, t) : n.setAttribute(t, String(i))
		})
	} function H(n, t, e) {
		n = document.createElement(n)

		return t && (M(t) ? C : j)(n, t), e && P(e, n), n
	} function Y(n, t, e) {
		if (z(e)) {
			return getComputedStyle(n)[t]
		} r(e) || (n.style[t] = `${e}`)
	} function q(n, t) {
		Y(n, 'display', t)
	} function U(n) {
		n.setActive && n.setActive() || n.focus({ preventScroll: !0 })
	} function K(n, t) {
		return n.getAttribute(t)
	} function J(n, t) {
		return n && n.classList.contains(t)
	} function Q(n) {
		return n.getBoundingClientRect()
	} function V(n) {
		y(n, (n) => {
			n && n.parentNode && n.parentNode.removeChild(n)
		})
	} function Z(n) {
		return A(new DOMParser().parseFromString(n, 'text/html').body)
	} function $(n, t) {
		n.preventDefault(), t && (n.stopPropagation(), n.stopImmediatePropagation())
	} function nn(n, t) {
		return n && n.querySelector(t)
	} function tn(n, t) {
		return t ? _(n.querySelectorAll(t)) : []
	} function en(n, t) {
		L(n, t, !1)
	} function on(n) {
		return n.timeStamp
	} function rn(n) {
		return M(n) ? n : n ? `${n}px` : ''
	} let un = 'splide'; let i = `data-${un}`; function sn(n, t) {
		if (!n) {
			throw new Error(`[${un}] ${t || ''}`)
		}
	} let cn = Math.min; let an = Math.max; let fn = Math.floor; let ln = Math.ceil; let dn = Math.abs; function pn(n, t, e) {
		return dn(n - t) < e
	} function hn(n, t, e, i) {
		let o = cn(t, e); var e = an(t, e)

		return i ? o < n && n < e : o <= n && n <= e
	} function vn(n, t, e) {
		let i = cn(t, e); var e = an(t, e)

		return cn(an(i, n), e)
	} function gn(n) {
		return (n > 0) - (n < 0)
	} function mn(t, n) {
		return y(n, (n) => {
			t = t.replace('%s', `${n}`)
		}), t
	} function yn(n) {
		return n < 10 ? `0${n}` : `${n}`
	} let bn = {}; function wn() {
		let s = []; function e(n, e, i) {
			y(n, (t) => {
				t && y(e, (n) => {
					n.split(' ').forEach((n) => {
						n = n.split('.'); i(t, n[0], n[1])
					})
				})
			})
		}

		return { bind(n, t, r, u) {
			e(n, t, (n, t, e) => {
				let i = 'addEventListener' in n; let o = i ? n.removeEventListener.bind(n, t, r, u) : n.removeListener.bind(n, r); i ? n.addEventListener(t, r, u) : n.addListener(r), s.push([n, t, e, r, o])
			})
		},
		unbind(n, t, o) {
			e(n, t, (t, e, i) => {
				s = s.filter((n) => {
					return !!(n[0] !== t || n[1] !== e || n[2] !== i || o && n[3] !== o) || (n[4](), !1)
				})
			})
		},
		dispatch(n, t, e) {
			let i

			return typeof CustomEvent === 'function' ? i = new CustomEvent(t, { bubbles: !0,
				detail: e }) : (i = document.createEvent('CustomEvent')).initCustomEvent(t, !0, !1, e), n.dispatchEvent(i), i
		},
		destroy() {
			s.forEach((n) => {
				n[4]()
			}), x(s)
		} }
	} let En = 'mounted'; let Sn = 'move'; let xn = 'moved'; let _n = 'shifted'; let Cn = 'click'; let Pn = 'active'; let kn = 'inactive'; let Ln = 'visible'; let An = 'hidden'; let Dn = 'slide:keydown'; let Mn = 'refresh'; let zn = 'updated'; let Nn = 'resize'; let Tn = 'resized'; let On = 'scroll'; let In = 'scrolled'; let u = 'destroy'; let Fn = 'navigation:mounted'; let jn = 'autoplay:play'; let Rn = 'autoplay:pause'; let Wn = 'lazyload:loaded'; function Gn(n) {
		let e = n ? n.event.bus : document.createDocumentFragment(); let i = wn()

		return n && n.event.on(u, i.destroy), T(i, { bus: e,
			on(n, t) {
				i.bind(e, m(n).join(' '), (n) => {
					t.apply(t, o(n.detail) ? n.detail : [])
				})
			},
			off: D(i.unbind, e),
			emit(n) {
				i.dispatch(e, n, _(arguments, 1))
			} })
	} function Xn(t, n, e, i) {
		let o; let r; let u = Date.now; let s = 0; let c = !0; let a = 0; function f() {
			if (!c) {
				if (s = t ? cn((u() - o) / t, 1) : 1, e && e(s), s >= 1 && (n(), o = u(), i && ++a >= i)) {
					return l()
				} p(f)
			}
		} function l() {
			c = !0
		} function d() {
			r && cancelAnimationFrame(r), c = !(r = s = 0)
		}

		return { start(n) {
			n || d(), o = u() - (n ? s * t : 0), c = !1, p(f)
		},
		rewind() {
			o = u(), s = 0, e && e(s)
		},
		pause: l,
		cancel: d,
		set(n) {
			t = n
		},
		isPaused() {
			return c
		} }
	} function s(n) {
		let t = n

		return { set(n) {
			t = n
		},
		is(n) {
			return b(m(n), t)
		} }
	} var e = 'Arrow'; let Bn = `${e}Left`; let Hn = `${e}Right`; let c = `${e}Up`; let a = `${e}Down`; let Yn = 'ttb'; let f = { width: ['height'],
		left: ['top', 'right'],
		right: ['bottom', 'left'],
		x: ['y'],
		X: ['Y'],
		Y: ['X'],
		ArrowLeft: [c, Hn],
		ArrowRight: [a, Bn] }; let qn = 'role'; let Un = 'tabindex'; var e = 'aria-'; let Kn = `${e}controls`; let Jn = `${e}current`; let Qn = `${e}selected`; let Vn = `${e}label`; let Zn = `${e}labelledby`; let $n = `${e}hidden`; let nt = `${e}orientation`; let tt = `${e}roledescription`; let l = `${e}live`; let et = `${e}busy`; let it = `${e}atomic`; let ot = [qn, Un, 'disabled', Kn, Jn, Vn, Zn, $n, nt, tt]; let rt = un; let ut = `${un}__track`; let st = `${un}__list`; let ct = `${un}__slide`; let at = `${ct}--clone`; let ft = `${ct}__container`; let lt = `${un}__arrows`; let dt = `${un}__arrow`; let pt = `${dt}--prev`; let ht = `${dt}--next`; let vt = `${un}__pagination`; let gt = `${vt}__page`; let mt = `${un}__progress` + '__bar'; let yt = `${un}__toggle`; let bt = `${un}__sr`; let wt = 'is-active'; let Et = 'is-prev'; let St = 'is-next'; let xt = 'is-visible'; let _t = 'is-loading'; let Ct = 'is-focus-in'; let Pt = [wt, xt, Et, St, _t, Ct]; let kt = 'touchstart mousedown'; let Lt = 'touchmove mousemove'; let At = 'touchend touchcancel mouseup click'; let Dt = 'slide'; let Mt = 'loop'; let zt = 'fade'; function Nt(o, e, t, r) {
		let i; let n = Gn(o); let u = n.on; let s = n.emit; let c = n.bind; let a = o.Components; let f = o.root; let l = o.options; let d = l.isNavigation; let p = l.updateOnMove; let h = l.i18n; let v = l.pagination; let g = l.slideFocus; let m = a.Direction.resolve; let y = K(r, 'style'); let b = K(r, Vn); let w = t > -1; let E = A(r, `.${ft}`); let S = tn(r, l.focusableNodes || ''); function x() {
			let n = o.splides.map((n) => {
				n = n.splide.Components.Slides.getAt(e)

				return n ? n.slide.id : ''
			}).join(' '); j(r, Vn, mn(h.slideX, (w ? t : e) + 1)), j(r, Kn, n), j(r, qn, g ? 'button' : ''), g && F(r, tt)
		} function _() {
			i || C()
		} function C() {
			let n; let t; i || (n = o.index, (t = P()) !== J(r, wt) && (L(r, wt, t), j(r, Jn, d && t || ''), s(t ? Pn : kn, k)), (function () {
				let n = (function () {
					if (o.is(zt)) {
						return P()
					} let n = Q(a.Elements.track); let t = Q(r); let e = m('left', !0); let i = m('right', !0)

					return fn(n[e]) <= ln(t[e]) && fn(t[i]) <= ln(n[i])
				})(); let t = !n && (!P() || w); o.state.is([R, W]) || j(r, $n, t || ''); j(S, Un, t ? -1 : ''), g && j(r, Un, t ? -1 : 0); n !== J(r, xt) && (L(r, xt, n), s(n ? Ln : An, k)); n || document.activeElement !== r || (n = a.Slides.getAt(o.index)) && U(n.slide)
			})(), L(r, Et, e === n - 1), L(r, St, e === n + 1))
		} function P() {
			let n = o.index

			return n === e || l.cloneStatus && n === t
		} var k = { index: e,
			slideIndex: t,
			slide: r,
			container: E,
			isClone: w,
			mount() {
				w || (r.id = `${f.id}-slide${yn(e + 1)}`, j(r, qn, v ? 'tabpanel' : 'group'), j(r, tt, h.slide), j(r, Vn, b || mn(h.slideLabel, [e + 1, o.length]))), c(r, 'click', D(s, Cn, k)), c(r, 'keydown', D(s, Dn, k)), u([xn, _n, In], C), u(Fn, x), p && u(Sn, _)
			},
			destroy() {
				i = !0, n.destroy(), en(r, Pt), F(r, ot), j(r, 'style', y), j(r, Vn, b || '')
			},
			update: C,
			style(n, t, e) {
				Y(e && E || r, n, t)
			},
			isWithin(n, t) {
				return n = dn(n - e), (n = !w && (l.rewind || o.is(Mt)) ? cn(n, o.length - n) : n) <= t
			} }

		return k
	} let Tt = `${i}-interval`; let Ot = { passive: !1,
		capture: !0 }; let It = { Spacebar: ' ',
		Right: Hn,
		Left: Bn,
		Up: c,
		Down: a }; function Ft(n) {
		return n = M(n) ? n : n.key, It[n] || n
	} let jt = 'keydown'; let Rt = `${i}-lazy`; let Wt = `${Rt}-srcset`; let Gt = `[${Rt}], [${Wt}]`; let Xt = [' ', 'Enter']; let Bt = Object.freeze({ __proto__: null,
		Media: function (i, n, o) {
			let r = i.state; let t = o.breakpoints || {}; let u = o.reducedMotion || {}; let e = wn(); let s = []; function c(n) {
				n && e.destroy()
			} function a(n, t) {
				t = matchMedia(t); e.bind(t, 'change', f), s.push([n, t])
			} function f() {
				let n = r.is(7); let t = o.direction; let e = s.reduce((n, t) => {
					return O(n, t[1].matches ? t[0] : {})
				}, {}); I(o), l(e), o.destroy ? i.destroy(o.destroy === 'completely') : n ? (c(!0), i.mount()) : t !== o.direction && i.refresh()
			} function l(n, t) {
				O(o, n), t && O(Object.getPrototypeOf(o), n), r.is(1) || i.emit(zn, o)
			}

			return { setup() {
				let e = o.mediaQuery === 'min'; h(t).sort((n, t) => {
					return e ? +n - +t : +t - +n
				}).forEach((n) => {
					a(t[n], `(${e ? 'min' : 'max'}-width:${n}px)`)
				}), a(u, d), f()
			},
			destroy: c,
			reduce(n) {
				matchMedia(d).matches && (n ? O(o, u) : I(o, h(u)))
			},
			set: l }
		},
		Direction: function (n, t, o) {
			return { resolve(n, t, e) {
				let i = (e = e || o.direction) !== 'rtl' || t ? e === Yn ? 0 : -1 : 1

				return f[n] && f[n][i] || n.replace(/width|left|right/i, (n, t) => {
					n = f[n.toLowerCase()][i] || n

					return t > 0 ? n.charAt(0).toUpperCase() + n.slice(1) : n
				})
			},
			orient(n) {
				return n * (o.direction === 'rtl' ? 1 : -1)
			} }
		},
		Elements: function (n, t, e) {
			let i; let o; let r; let u = Gn(n); let s = u.on; let c = u.bind; let a = n.root; let f = e.i18n; let l = {}; let d = []; let p = []; let h = []; function v() {
				i = y(`.${ut}`), o = A(i, `.${st}`), sn(i && o, 'A track/list element is missing.'), E(d, S(o, `.${ct}:not(.${at})`)), N({ arrows: lt,
					pagination: vt,
					prev: pt,
					next: ht,
					bar: mt,
					toggle: yt }, (n, t) => {
					l[t] = y(`.${n}`)
				}), T(l, { root: a,
					track: i,
					list: o,
					slides: d }), (function () {
					let n = a.id || (function (n) {
						return `${n}${yn(bn[n] = (bn[n] || 0) + 1)}`
					})(un); let t = e.role; a.id = n, i.id = i.id || `${n}-track`, o.id = o.id || `${n}-list`, !K(a, qn) && a.tagName !== 'SECTION' && t && j(a, qn, t); j(a, tt, f.carousel), j(o, qn, 'presentation')
				})(), m()
			} function g(n) {
				let t = ot.concat('style'); x(d), en(a, p), en(i, h), F([i, o], t), F(a, n ? t : ['style', tt])
			} function m() {
				en(a, p), en(i, h), p = b(rt), h = b(ut), C(a, p), C(i, h), j(a, Vn, e.label), j(a, Zn, e.labelledby)
			} function y(n) {
				n = nn(a, n)

				return n && (function (n, t) {
					if (w(n.closest)) {
						return n.closest(t)
					} for (var e = n; e && e.nodeType === 1 && !B(e, t);) {
						e = e.parentElement
					}

					return e
				})(n, `.${rt}`) === a ? n : void 0
			} function b(n) {
				return [`${n}--${e.type}`, `${n}--${e.direction}`, e.drag && `${n}--draggable`, e.isNavigation && `${n}--nav`, n === rt && wt]
			}

			return T(l, { setup: v,
				mount() {
					s(Mn, g), s(Mn, v), s(zn, m), c(document, `${kt} keydown`, (n) => {
						r = n.type === 'keydown'
					}, { capture: !0 }), c(a, 'focusin', () => {
						L(a, Ct, !!r)
					})
				},
				destroy: g })
		},
		Slides: function (i, o, r) {
			let n = Gn(i); let t = n.on; let u = n.emit; let s = n.bind; let c = (n = o.Elements).slides; let a = n.list; let f = []; function e() {
				c.forEach((n, t) => {
					d(n, t, -1)
				})
			} function l() {
				h((n) => {
					n.destroy()
				}), x(f)
			} function d(n, t, e) {
				n = Nt(i, t, e, n); n.mount(), f.push(n)
			} function p(n) {
				return n ? v((n) => {
					return !n.isClone
				}) : f
			} function h(n, t) {
				p(t).forEach(n)
			} function v(t) {
				return f.filter(w(t) ? t : (n) => {
					return M(t) ? B(n.slide, t) : b(m(t), n.index)
				})
			}

			return { mount() {
				e(), t(Mn, l), t(Mn, e), t([En, Mn], () => {
					f.sort((n, t) => {
						return n.index - t.index
					})
				})
			},
			destroy: l,
			update() {
				h((n) => {
					n.update()
				})
			},
			register: d,
			get: p,
			getIn(n) {
				let t = o.Controller; let e = t.toIndex(n); let i = t.hasFocus() ? 1 : r.perPage

				return v((n) => {
					return hn(n.index, e, e + i - 1)
				})
			},
			getAt(n) {
				return v(n)[0]
			},
			add(n, o) {
				y(n, (n) => {
					let t; let e; let i; g(n = M(n) ? Z(n) : n) && ((t = c[o]) ? k(n, t) : P(a, n), C(n, r.classes.slide), n = n, e = D(u, Nn), n = tn(n, 'img'), (i = n.length) ? n.forEach((n) => {
						s(n, 'load error', () => {
							--i || e()
						})
					}) : e())
				}), u(Mn)
			},
			remove(n) {
				V(v(n).map((n) => {
					return n.slide
				})), u(Mn)
			},
			forEach: h,
			filter: v,
			style(t, e, i) {
				h((n) => {
					n.style(t, e, i)
				})
			},
			getLength(n) {
				return (n ? c : f).length
			},
			isEnough() {
				return f.length > r.perPage
			} }
		},
		Layout: function (n, t, e) {
			let i; let o; let r = (c = Gn(n)).on; let u = c.bind; let s = c.emit; var c = t.Slides; let a = t.Direction.resolve; let f = (t = t.Elements).root; let l = t.track; let d = t.list; let p = c.getAt; let h = c.style; function v() {
				o = null, i = e.direction === Yn, Y(f, 'maxWidth', rn(e.width)), Y(l, a('paddingLeft'), m(!1)), Y(l, a('paddingRight'), m(!0)), g()
			} function g() {
				let n = Q(f); o && o.width === n.width && o.height === n.height || (Y(l, 'height', (function () {
					let n = ''; i && (sn(n = y(), 'height or heightRatio is missing.'), n = `calc(${n} - ${m(!1)} - ${m(!0)})`)

					return n
				})()), h(a('marginRight'), rn(e.gap)), h('width', e.autoWidth ? null : rn(e.fixedWidth) || (i ? '' : b())), h('height', rn(e.fixedHeight) || (i ? e.autoHeight ? null : b() : y()), !0), o = n, s(Tn))
			} function m(n) {
				let t = e.padding; var n = a(n ? 'right' : 'left')

				return t && rn(t[n] || (X(t) ? 0 : t)) || '0px'
			} function y() {
				return rn(e.height || Q(d).width * e.heightRatio)
			} function b() {
				let n = rn(e.gap)

				return `calc((100%${n && ` + ${n}`})/${e.perPage || 1}${n && ` - ${n}`})`
			} function w(n, t) {
				let e = p(n); if (e) {
					n = Q(e.slide)[a('right')], e = Q(d)[a('left')]

					return dn(n - e) + (t ? 0 : E())
				}

				return 0
			} function E() {
				let n = p(0)

				return n && parseFloat(Y(n.slide, a('marginRight'))) || 0
			}

			return { mount() {
				let n; let t; let e; v(), u(window, 'resize load', (n = D(s, Nn), function () {
					e || (e = Xn(t || 0, () => {
						n(), e = null
					}, null, 1)).start()
				})), r([zn, Mn], v), r(Nn, g)
			},
			listSize() {
				return Q(d)[a('width')]
			},
			slideSize(n, t) {
				return (n = p(n || 0)) ? Q(n.slide)[a('width')] + (t ? 0 : E()) : 0
			},
			sliderSize() {
				return w(n.length - 1, !0) - w(-1, !0)
			},
			totalSize: w,
			getPadding(n) {
				return parseFloat(Y(l, a(`padding${n ? 'Right' : 'Left'}`))) || 0
			} }
		},
		Clones: function (s, e, c) {
			let n; let t = Gn(s); let i = t.on; let o = t.emit; let a = e.Elements; let f = e.Slides; let r = e.Direction.resolve; let l = []; function u() {
				(n = h()) && ((function (o) {
					let r = f.get().slice(); let u = r.length; if (u) {
						for (;r.length < o;) {
							E(r, r)
						}E(r.slice(-o), r.slice(0, o)).forEach((n, t) => {
							let e = t < o; let i = (function (n, t) {
								n = n.cloneNode(!0)

								return C(n, c.classes.clone), n.id = `${s.root.id}-clone${yn(t + 1)}`, n
							})(n.slide, t); e ? k(i, r[0].slide) : P(a.list, i), E(l, i), f.register(i, t - o + (e ? 0 : u), n.index)
						})
					}
				})(n), o(Nn))
			} function d() {
				V(l), x(l)
			} function p() {
				n < h() && o(Mn)
			} function h() {
				let n; let t = c.clones

				return s.is(Mt) ? t || (t = (n = c[r('fixedWidth')] && e.Layout.slideSize(0)) && ln(Q(a.track)[r('width')] / n) || c[r('autoWidth')] && s.length || 2 * c.perPage) : t = 0, t
			}

			return { mount() {
				u(), i(Mn, d), i(Mn, u), i([zn, Nn], p)
			},
			destroy: d }
		},
		Move: function (i, s, o) {
			let u; let n = Gn(i); let t = n.on; let c = n.emit; let a = i.state.set; let r = (n = s.Layout).slideSize; let e = n.getPadding; let f = n.totalSize; let l = n.listSize; let d = n.sliderSize; let p = (n = s.Direction).resolve; let h = n.orient; let v = (n = s.Elements).list; let g = n.track; function m() {
				s.Controller.isBusy() || (s.Scroll.cancel(), y(i.index), s.Slides.update())
			} function y(n) {
				b(x(n, !0))
			} function b(n, t) {
				i.is(zt) || (t = t ? n : (function (n) {
					{ let t; let e; i.is(Mt) && (t = S(n), e = t > s.Controller.getEnd(), (t < 0 || e) && (n = w(n, e))) }

					return n
				})(n), Y(v, 'transform', `translate${p('X')}(${t}px)`), n !== t && c(_n))
			} function w(n, t) {
				let e = n - C(t); let i = d()

				return n -= h(i * (ln(dn(e) / i) || 1)) * (t ? 1 : -1)
			} function E() {
				b(_()), u.cancel()
			} function S(n) {
				for (var t = s.Slides.get(), e = 0, i = 1 / 0, o = 0; o < t.length; o++) {
					let r = t[o].index; let u = dn(x(r, !0) - n); if (!(u <= i)) {
						break
					} i = u, e = r
				}

				return e
			} function x(n, t) {
				var e = h(f(n - 1) - (e = n, (n = o.focus) === 'center' ? (l() - r(e, !0)) / 2 : +n * r(e) || 0))

				return t ? (function (n) {
					o.trimSpace && i.is(Dt) && (n = vn(n, 0, h(d() - l())))

					return n
				})(e) : e
			} function _() {
				let n = p('left')

				return Q(v)[n] - Q(g)[n] + h(e(!1))
			} function C(n) {
				return x(n ? s.Controller.getEnd() : 0, !!o.trimSpace)
			}

			return { mount() {
				u = s.Transition, t([En, Tn, zn, Mn], m)
			},
			move(n, t, e, i) {
				let o; let r; n !== t && (o = e < n, r = h(w(_(), o)), o ? r >= 0 : r <= v[p('scrollWidth')] - Q(g)[p('width')]) && (E(), b(w(_(), e < n), !0)), a(R), c(Sn, t, e, n), u.start(t, () => {
					a(3), c(xn, t, e, n), i && i()
				})
			},
			jump: y,
			translate: b,
			shift: w,
			cancel: E,
			toIndex: S,
			toPosition: x,
			getPosition: _,
			getLimit: C,
			exceededLimit(n, t) {
				t = z(t) ? _() : t; let e = !0 !== n && h(t) < h(C(!1)); var t = !1 !== n && h(t) > h(C(!0))

				return e || t
			},
			reposition: m }
		},
		Controller: function (r, o, u) {
			let s; let c; let a; let n = Gn(r).on; let f = o.Move; let l = f.getPosition; let i = f.getLimit; let d = f.toPosition; let t = o.Slides; let p = t.isEnough; let e = t.getLength; let h = r.is(Mt); let v = r.is(Dt); let g = D(E, !1); let m = D(E, !0); let y = u.start || 0; let b = y; function w() {
				s = e(!0), c = u.perMove, a = u.perPage; let n = vn(y, 0, s - 1); n !== y && (y = n, f.reposition())
			} function E(n, t) {
				var e = c || (L() ? 1 : a); var e = S(y + e * (n ? -1 : 1), y, !(c || L()))

				return e === -1 && v && !pn(l(), i(!n), 1) ? n ? 0 : _() : t ? e : x(e)
			} function S(n, t, e) {
				let i; let o

				return p() ? (i = _(), (o = (function (n) {
					if (v && u.trimSpace === 'move' && n !== y) {
						for (let t = l(); t === d(n, !0) && hn(n, 0, r.length - 1, !u.rewind);) {
							n < y ? --n : ++n
						}
					}

					return n
				})(n)) !== n && (t = n, n = o, e = !1), n < 0 || i < n ? n = c || !hn(0, n, t, !0) && !hn(i, t, n, !0) ? h ? e ? n < 0 ? -(s % a || a) : s : n : u.rewind ? n < 0 ? i : 0 : -1 : C(P(n)) : e && n !== t && (n = C(P(t) + (n < t ? -1 : 1)))) : n = -1, n
			} function x(n) {
				return h ? (n + s) % s || 0 : n
			} function _() {
				return an(s - (L() || h && c ? 1 : a), 0)
			} function C(n) {
				return vn(L() ? n : a * n, 0, _())
			} function P(n) {
				return L() ? n : fn((n >= _() ? s - 1 : n) / a)
			} function k(n) {
				n !== y && (b = y, y = n)
			} function L() {
				return !z(u.focus) || u.isNavigation
			} function A() {
				return r.state.is([R, W]) && !!u.waitForTransition
			}

			return { mount() {
				w(), n([zn, Mn], w)
			},
			go(n, t, e) {
				let i; A() || (n = x(i = (function (n) {
					let t = y; { let e; let i; M(n) ? (i = n.match(/([+\-<>])(\d+)?/) || [], e = i[1], i = i[2], e === '+' || e === '-' ? t = S(y + +`${e}${+i || 1}`, y) : e === '>' ? t = i ? C(+i) : g(!0) : e === '<' && (t = m(!0))) : t = h ? n : vn(n, 0, _()) }

					return t
				})(n))) > -1 && (t || n !== y) && (k(n), f.move(i, n, b, e))
			},
			scroll(n, t, e, i) {
				o.Scroll.scroll(n, t, e, () => {
					k(x(f.toIndex(l()))), i && i()
				})
			},
			getNext: g,
			getPrev: m,
			getAdjacent: E,
			getEnd: _,
			setIndex: k,
			getIndex(n) {
				return n ? b : y
			},
			toIndex: C,
			toPage: P,
			toDest(n) {
				return n = f.toIndex(n), v ? vn(n, 0, _()) : n
			},
			hasFocus: L,
			isBusy: A }
		},
		Arrows: function (o, n, t) {
			let e; let i; let r = Gn(o); let u = r.on; let s = r.bind; let c = r.emit; let a = t.classes; let f = t.i18n; let l = n.Elements; let d = n.Controller; let p = l.arrows; let h = l.track; let v = p; let g = l.prev; let m = l.next; let y = {}; function b() {
				!(function () {
					let n = t.arrows; !n || g && m || (v = p || H('div', a.arrows), g = x(!0), m = x(!1), e = !0, P(v, [g, m]), p || k(v, h)); g && m && (T(y, { prev: g,
						next: m }), q(v, n ? '' : 'none'), C(v, i = `${lt}--${t.direction}`), n && (u([xn, Mn, In], _), s(m, 'click', D(S, '>')), s(g, 'click', D(S, '<')), _(), j([g, m], Kn, h.id), c('arrows:mounted', g, m)))
				})(), u(zn, w)
			} function w() {
				E(), b()
			} function E() {
				r.destroy(), en(v, i), e ? (V(p ? [g, m] : v), g = m = null) : F([g, m], ot)
			} function S(n) {
				d.go(n, !0)
			} function x(n) {
				return Z(`<button class="${a.arrow} ${n ? a.prev : a.next}" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 15" focusable="false"><path d="${t.arrowPath || 'M1.25029 6.75969C0.859766 7.15021 0.859766 7.78338 1.25029 8.1739L7.61425 14.5379C8.00478 14.9284 8.63794 14.9284 9.02847 14.5379C9.41899 14.1473 9.41899 13.5142 9.02847 13.1237L3.37161 7.4668L9.02847 1.80994C9.41899 1.41942 9.41899 0.786253 9.02847 0.395729C8.63794 0.00520468 8.00478 0.00520468 7.61425 0.395729L1.25029 6.75969ZM3.13825 6.4668H1.9574V8.4668H3.13825V6.4668Z'}" />`)
			} function _() {
				var n = o.index; let t = d.getPrev(); let e = d.getNext(); let i = t > -1 && n < t ? f.last : f.prev; var n = e > -1 && e < n ? f.first : f.next; g.disabled = t < 0, m.disabled = e < 0, j(g, Vn, i), j(m, Vn, n), c('arrows:updated', g, m, t, e)
			}

			return { arrows: y,
				mount: b,
				destroy: E }
		},
		Autoplay: function (n, t, e) {
			let i; let o; let r = Gn(n); let u = r.on; let s = r.bind; let c = r.emit; let a = Xn(e.interval, n.go.bind(n, '>'), (n) => {
				let t = l.bar; t && Y(t, 'width', `${100 * n}%`), c('autoplay:playing', n)
			}); let f = a.isPaused; var l = t.Elements; let d = (n = t.Elements).root; let p = n.toggle; let h = e.autoplay; let v = h === 'pause'; function g() {
				f() && t.Slides.isEnough() && (a.start(!e.resetProgress), o = i = v = !1, b(), c(jn))
			} function m(n) {
				v = !!(n = void 0 === n ? !0 : n), b(), f() || (a.pause(), c(Rn))
			} function y() {
				v || (i || o ? m(!1) : g())
			} function b() {
				p && (L(p, wt, !v), j(p, Vn, e.i18n[v ? 'play' : 'pause']))
			} function w(n) {
				n = t.Slides.getAt(n); a.set(n && +K(n.slide, Tt) || e.interval)
			}

			return { mount() {
				h && ((function () {
					e.pauseOnHover && s(d, 'mouseenter mouseleave', (n) => {
						i = n.type === 'mouseenter', y()
					}); e.pauseOnFocus && s(d, 'focusin focusout', (n) => {
						o = n.type === 'focusin', y()
					}); p && s(p, 'click', () => {
						v ? g() : m(!0)
					}); u([Sn, On, Mn], a.rewind), u(Sn, w)
				})(), p && j(p, Kn, l.track.id), v || g(), b())
			},
			destroy: a.cancel,
			play: g,
			pause: m,
			isPaused: f }
		},
		Cover: function (n, t, e) {
			let i = Gn(n).on; function o(e) {
				t.Slides.forEach((n) => {
					let t = A(n.container || n.slide, 'img'); t && t.src && r(e, t, n)
				})
			} function r(n, t, e) {
				e.style('background', n ? `center/cover no-repeat url("${t.src}")` : '', !0), q(t, n ? 'none' : '')
			}

			return { mount() {
				e.cover && (i(Wn, D(r, !0)), i([En, zn, Mn], D(o, !0)))
			},
			destroy: D(o, !1) }
		},
		Scroll: function (r, s, u) {
			let c; let a; let n = Gn(r); let t = n.on; let f = n.emit; let l = r.state.set; let d = s.Move; let p = d.getPosition; let h = d.getLimit; let v = d.exceededLimit; let g = d.translate; let m = 1; function y(n, t, e, i, o) {
				let r = p(); E(), e && (e = s.Layout.sliderSize(), u = gn(n) * e * fn(dn(n) / e) || 0, n = d.toPosition(s.Controller.toDest(n % e)) + u); var u = pn(r, n, 1); m = 1, t = u ? 0 : t || an(dn(n - r) / 1.5, 800), a = i, c = Xn(t, b, D(w, r, n, o), 1), l(W), f(On), c.start()
			} function b() {
				l(3), a && a(), f(In)
			} function w(n, t, e, i) {
				let o = p(); var n = (n + (t - n) * (n = i, (i = u.easingFunc) ? i(n) : 1 - Math.pow(1 - n, 4)) - o) * m; g(o + n), r.is(Dt) && !e && v() && (m *= 0.6, dn(n) < 10 && y(h(v(!0)), 600, !1, a, !0))
			} function E() {
				c && c.cancel()
			} function e() {
				c && !c.isPaused() && (E(), b())
			}

			return { mount() {
				t(Sn, E), t([zn, Mn], e)
			},
			destroy: E,
			scroll: y,
			cancel: e }
		},
		Drag: function (r, i, u) {
			let s; let t; let o; let c; let a; let f; let l; let d; let n = Gn(r); let e = n.on; let p = n.emit; let h = n.bind; let v = n.unbind; let g = r.state; let m = i.Move; let y = i.Scroll; let b = i.Controller; let w = i.Elements.track; let E = i.Media.reduce; let S = (n = i.Direction).resolve; let x = n.orient; let _ = m.getPosition; let C = m.exceededLimit; let P = !1; function k() {
				let n = u.drag; j(!n), c = n === 'free'
			} function L(n) {
				let t; let e; let i; f = !1, l || (t = F(n), e = n.target, i = u.noDrag, B(e, `.${gt}, .${dt}`) || i && B(e, i) || !t && n.button || (b.isBusy() ? $(n, !0) : (d = t ? w : window, a = g.is([R, W]), o = null, h(d, Lt, A, Ot), h(d, At, D, Ot), m.cancel(), y.cancel(), z(n))))
			} function A(n) {
				let t; let e; let i; let o; g.is(6) || (g.set(6), p('drag')), n.cancelable && (a ? (m.translate(s + N(n) / (P && r.is(Dt) ? 5 : 1)), e = T(n) > 200, i = P !== (P = C()), (e || i) && z(n), f = !0, p('dragging'), $(n)) : dn(N(o = n)) > dn(N(o, !0)) && (t = n, e = u.dragMinThreshold, i = X(e), o = i && e.mouse || 0, e = (i ? e.touch : +e) || 10, a = dn(N(t)) > (F(t) ? e : o), $(n)))
			} function D(n) {
				g.is(6) && (g.set(3), p('dragged')), a && ((function (n) {
					let t = (function (n) {
						if (r.is(Mt) || !P) {
							let t = T(n); if (t && t < 200) {
								return N(n) / t
							}
						}

						return 0
					})(n); let e = (function (n) {
						return _() + gn(n) * cn(dn(n) * (u.flickPower || 600), c ? 1 / 0 : i.Layout.listSize() * (u.flickMaxPages || 1))
					})(t); var n = u.rewind && u.rewindByDrag; E(!1), c ? b.scroll(e, 0, u.snap) : r.is(zt) ? b.go(x(gn(t)) < 0 ? n ? '<' : '-' : n ? '>' : '+') : r.is(Dt) && P && n ? b.go(C(!0) ? '>' : '<') : b.go(b.toDest(e), !0); E(!0)
				})(n), $(n)), v(d, Lt, A), v(d, At, D), a = !1
			} function M(n) {
				!l && f && $(n, !0)
			} function z(n) {
				o = t, t = n, s = _()
			} function N(n, t) {
				return I(n, t) - I(O(n), t)
			} function T(n) {
				return on(n) - on(O(n))
			} function O(n) {
				return t === n && o || t
			} function I(n, t) {
				return (F(n) ? n.changedTouches[0] : n)[`page${S(t ? 'Y' : 'X')}`]
			} function F(n) {
				return typeof TouchEvent !== 'undefined' && n instanceof TouchEvent
			} function j(n) {
				l = n
			}

			return { mount() {
				h(w, Lt, G, Ot), h(w, At, G, Ot), h(w, kt, L, Ot), h(w, 'click', M, { capture: !0 }), h(w, 'dragstart', $), e([En, zn], k)
			},
			disable: j,
			isDragging() {
				return a
			} }
		},
		Keyboard: function (t, n, e) {
			let i; let o; let r = Gn(t); let u = r.on; let s = r.bind; let c = r.unbind; let a = t.root; let f = n.Direction.resolve; function l() {
				let n = e.keyboard; n && (i = n === 'global' ? window : a, s(i, jt, h))
			} function d() {
				c(i, jt)
			} function p() {
				let n = o; o = !0, v(() => {
					o = n
				})
			} function h(n) {
				o || ((n = Ft(n)) === f(Bn) ? t.go('<') : n === f(Hn) && t.go('>'))
			}

			return { mount() {
				l(), u(zn, d), u(zn, l), u(Sn, p)
			},
			destroy: d,
			disable(n) {
				o = n
			} }
		},
		LazyLoad: function (e, n, o) {
			let t = Gn(e); let i = t.on; let r = t.off; let u = t.bind; let s = t.emit; let c = o.lazyLoad === 'sequential'; let a = [En, Mn, xn, In]; let f = []; function l() {
				x(f), n.Slides.forEach((i) => {
					tn(i.slide, Gt).forEach((n) => {
						let t = K(n, Rt); let e = K(n, Wt); t === n.src && e === n.srcset || (t = o.classes.spinner, e = A(e = n.parentElement, `.${t}`) || H('span', t, e), f.push([n, i, e]), n.src || q(n, 'none'))
					})
				}), c && v()
			} function d() {
				(f = f.filter((n) => {
					let t = o.perPage * ((o.preloadPages || 1) + 1) - 1

					return !n[1].isWithin(e.index, t) || p(n)
				})).length || r(a)
			} function p(n) {
				let t = n[0]; C(n[1].slide, _t), u(t, 'load error', D(h, n)), j(t, 'src', K(t, Rt)), j(t, 'srcset', K(t, Wt)), F(t, Rt), F(t, Wt)
			} function h(n, t) {
				let e = n[0]; let i = n[1]; en(i.slide, _t), t.type !== 'error' && (V(n[2]), q(e, ''), s(Wn, e, i), s(Nn)), c && v()
			} function v() {
				f.length && p(f.shift())
			}

			return { mount() {
				o.lazyLoad && (l(), i(Mn, l), c || i(a, d))
			},
			destroy: D(x, f) }
		},
		Pagination: function (f, n, l) {
			let d; let p; let t = Gn(f); let e = t.on; let i = t.emit; let h = t.bind; let v = n.Slides; let g = n.Elements; let o = n.Controller; let m = o.hasFocus; let r = o.getIndex; let u = o.go; let s = n.Direction.resolve; let y = []; function c() {
				d && (V(g.pagination ? _(d.children) : d), en(d, p), x(y), d = null), t.destroy()
			} function b(n) {
				u(`>${n}`, !0)
			} function w(n, t) {
				let e = y.length; let i = Ft(t); let o = E(); let r = -1; i === s(Hn, !1, o) ? r = ++n % e : i === s(Bn, !1, o) ? r = (--n + e) % e : i === 'Home' ? r = 0 : i === 'End' && (r = e - 1); e = y[r]; e && (U(e.button), u(`>${r}`), $(t, !0))
			} function E() {
				return l.paginationDirection || l.direction
			} function a(n) {
				return y[o.toPage(n)]
			} function S() {
				let n; let t = a(r(!0)); let e = a(r()); t && (en(n = t.button, wt), F(n, Qn), j(n, Un, -1)), e && (C(n = e.button, wt), j(n, Qn, !0), j(n, Un, '')), i('pagination:updated', { list: d,
					items: y }, t, e)
			}

			return { items: y,
				mount: function n() {
					c(), e([zn, Mn], n), l.pagination && v.isEnough() && (e([Sn, On, In], S), (function () {
						let n = f.length; let t = l.classes; let e = l.i18n; let i = l.perPage; let o = m() ? n : ln(n / i); C(d = g.pagination || H('ul', t.pagination, g.track.parentElement), p = `${vt}--${E()}`), j(d, qn, 'tablist'), j(d, Vn, e.select), j(d, nt, E() === Yn ? 'vertical' : ''); for (let r = 0; r < o; r++) {
							let u = H('li', null, d); let s = H('button', { 'class': t.page,
								'type': 'button' }, u); let c = v.getIn(r).map((n) => {
								return n.slide.id
							}); let a = !m() && i > 1 ? e.pageX : e.slideX; h(s, 'click', D(b, r)), l.paginationKeyboard && h(s, 'keydown', D(w, r)), j(u, qn, 'presentation'), j(s, qn, 'tab'), j(s, Kn, c.join(' ')), j(s, Vn, mn(a, r + 1)), j(s, Un, -1), y.push({ li: u,
								button: s,
								page: r })
						}
					})(), S(), i('pagination:mounted', { list: d,
						items: y }, a(f.index)))
				},
				destroy: c,
				getAt: a,
				update: S }
		},
		Sync: function (e, n, t) {
			let i = t.isNavigation; let o = t.slideFocus; let r = []; function u() {
				let n; let t; e.splides.forEach((n) => {
					n.isParent || (c(e, n.splide), c(n.splide, e))
				}), i && (n = Gn(e), (t = n.on)(Cn, f), t(Dn, l), t([En, zn], a), r.push(n), n.emit(Fn, e.splides))
			} function s() {
				r.forEach((n) => {
					n.destroy()
				}), x(r)
			} function c(n, i) {
				n = Gn(n); n.on(Sn, (n, t, e) => {
					i.go(i.is(Mt) ? e : n)
				}), r.push(n)
			} function a() {
				j(n.Elements.list, nt, t.direction === Yn ? 'vertical' : '')
			} function f(n) {
				e.go(n.index)
			} function l(n, t) {
				b(Xt, Ft(t)) && (f(n), $(t))
			}

			return { setup() {
				e.options = { slideFocus: z(o) ? i : o }
			},
			mount: u,
			destroy: s,
			remount() {
				s(), u()
			} }
		},
		Wheel: function (u, s, c) {
			let n = Gn(u).bind; let a = 0; function t(n) {
				let t; let e; let i; let o; let r; n.cancelable && (r = (t = n.deltaY) < 0, e = on(n), i = c.wheelMinThreshold || 0, o = c.wheelSleep || 0, dn(t) > i && o < e - a && (u.go(r ? '<' : '>'), a = e), r = r, c.releaseWheel && !u.state.is(R) && s.Controller.getAdjacent(r) === -1 || $(n))
			}

			return { mount() {
				c.wheel && n(s.Elements.track, 'wheel', t, Ot)
			} }
		},
		Live: function (n, t, e) {
			let i = Gn(n).on; let o = t.Elements.track; let r = e.live && !e.isNavigation; let u = H('span', bt); let s = Xn(90, D(c, !1)); function c(n) {
				j(o, et, n), n ? (P(o, u), s.start()) : V(u)
			} function a(n) {
				r && j(o, l, n ? 'off' : 'polite')
			}

			return { mount() {
				r && (a(!t.Autoplay.isPaused()), j(o, it, !0), u.textContent = '…', i(jn, D(a, !0)), i(Rn, D(a, !1)), i([xn, In], D(c, !0)))
			},
			disable: a,
			destroy() {
				F(o, [l, it, et]), V(u)
			} }
		} }); let Ht = { type: 'slide',
		role: 'region',
		speed: 400,
		perPage: 1,
		cloneStatus: !0,
		arrows: !0,
		pagination: !0,
		paginationKeyboard: !0,
		interval: 5e3,
		pauseOnHover: !0,
		pauseOnFocus: !0,
		resetProgress: !0,
		easing: 'cubic-bezier(0.25, 1, 0.5, 1)',
		drag: !0,
		direction: 'ltr',
		trimSpace: !0,
		focusableNodes: 'a, button, textarea, input, select, iframe',
		live: !0,
		classes: { slide: ct,
			clone: at,
			arrows: lt,
			arrow: dt,
			prev: pt,
			next: ht,
			pagination: vt,
			page: gt,
			spinner: `${un}__spinner` },
		i18n: { prev: 'Previous slide',
			next: 'Next slide',
			first: 'Go to first slide',
			last: 'Go to last slide',
			slideX: 'Go to slide %s',
			pageX: 'Go to page %s',
			play: 'Start autoplay',
			pause: 'Pause autoplay',
			carousel: 'carousel',
			slide: 'slide',
			select: 'Select a slide to show',
			slideLabel: '%s of %s' },
		reducedMotion: { speed: 0,
			rewindSpeed: 0,
			autoplay: 'pause' } }; function Yt(n, i, t) {
		let e = Gn(n).on

		return { mount() {
			e([En, Mn], () => {
				v(() => {
					i.Slides.style('transition', `opacity ${t.speed}ms ${t.easing}`)
				})
			})
		},
		start(n, t) {
			let e = i.Elements.track; Y(e, 'height', rn(Q(e).height)), v(() => {
				t(), Y(e, 'height', '')
			})
		},
		cancel: G }
	} function qt(r, n, u) {
		let s; let t = Gn(r).bind; let c = n.Move; let a = n.Controller; let f = n.Scroll; let e = n.Elements.list; let l = D(Y, e, 'transition'); function i() {
			l(''), f.cancel()
		}

		return { mount() {
			t(e, 'transitionend', (n) => {
				n.target === e && s && (i(), s())
			})
		},
		start(n, t) {
			let e = c.toPosition(n, !0); let i = c.getPosition(); let o = (function (n) {
				let t = u.rewindSpeed; if (r.is(Dt) && t) {
					let e = a.getIndex(!0); let i = a.getEnd(); if (e === 0 && i <= n || i <= e && n === 0) {
						return t
					}
				}

				return u.speed
			})(n); dn(e - i) >= 1 && o >= 1 ? u.useScroll ? f.scroll(e, o, !1, t) : (l(`transform ${o}ms ${u.easing}`), c.translate(e, !0), s = t) : (c.jump(n), t())
		},
		cancel: i }
	}a = (function () {
		function e(n, t) {
			this.event = Gn(), this.Components = {}, this.state = s(1), this.splides = [], this._o = {}, this._E = {}; n = M(n) ? nn(document, n) : n; sn(n, `${n} is invalid.`), t = O({ label: K(this.root = n, Vn) || '',
				labelledby: K(n, Zn) || '' }, Ht, e.defaults, t || {}); try {
				O(t, JSON.parse(K(n, i)))
			} catch (n) {
				sn(!1, 'Invalid JSON')
			} this._o = Object.create(O({}, t))
		} let n = e.prototype

		return n.mount = function (n, t) {
			let e = this; let i = this.state; let o = this.Components

			return sn(i.is([1, 7]), 'Already mounted!'), i.set(1), this._C = o, this._T = t || this._T || (this.is(zt) ? Yt : qt), this._E = n || this._E, N(T({}, Bt, this._E, { Transition: this._T }), (n, t) => {
				n = n(e, o, e._o); (o[t] = n).setup && n.setup()
			}), N(o, (n) => {
				n.mount && n.mount()
			}), this.emit(En), C(this.root, 'is-initialized'), i.set(3), this.emit('ready'), this
		}, n.sync = function (n) {
			return this.splides.push({ splide: n }), n.splides.push({ splide: this,
				isParent: !0 }), this.state.is(3) && (this._C.Sync.remount(), n.Components.Sync.remount()), this
		}, n.go = function (n) {
			return this._C.Controller.go(n), this
		}, n.on = function (n, t) {
			return this.event.on(n, t), this
		}, n.off = function (n) {
			return this.event.off(n), this
		}, n.emit = function (n) {
			let t

			return (t = this.event).emit.apply(t, [n].concat(_(arguments, 1))), this
		}, n.add = function (n, t) {
			return this._C.Slides.add(n, t), this
		}, n.remove = function (n) {
			return this._C.Slides.remove(n), this
		}, n.is = function (n) {
			return this._o.type === n
		}, n.refresh = function () {
			return this.emit(Mn), this
		}, n.destroy = function (t) {
			void 0 === t && (t = !0); let n = this.event; let e = this.state

			return e.is(1) ? Gn(this).on('ready', this.destroy.bind(this, t)) : (N(this._C, (n) => {
				n.destroy && n.destroy(t)
			}, !0), n.emit(u), n.destroy(), t && x(this.splides), e.set(7)), this
		}, _createClass(e, [{ key: 'options',
			get() {
				return this._o
			},
			set(n) {
				this._C.Media.set(n, !0)
			} }, { key: 'length',
			get() {
				return this._C.Slides.getLength(!0)
			} }, { key: 'index',
			get() {
				return this._C.Controller.getIndex()
			} }]), e
	})()

	return a.defaults = {}, a.STATES = n, a
})
// # sourceMappingURL=splide.min.js.map
